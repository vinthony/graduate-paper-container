抽象表达式的递归函数和他们的机器计算 第一部分

约翰·麦卡锡 麻省理工学院 剑桥 梅州

1960年4月

# 1. 介绍
一个被称作`LISP(被用作表处理)`的程序系统程序系统已经被MIT的人工智能组开发出来并且能够运行在IBM 704 电脑上。这个系统被设计来方便一个称作“`Advice Taker`”的特殊的系统来做实验,在这里机器能够被教导去递交定义和听取命令还能够在这些教导中表现出直觉。“`Advice Taker`”最早在1958年11月提出`[1]`。主要的需求是控制表达式序列化展示的和输入句子的一个程序系统，因此`Advice Taker`系统能够得出结论

在开发`LISP`系统的过程中经历了一些简化的歩奏，最终基于偏递归函数表达式和一部分的抽象表达式构造了这个体系。这里的描述独立于IBM 704 电脑，或者其他电脑，而且如今它好像更适合解释通过一系列`s-表达式`和被称作`S-函数`的函数来了解这个系统

这篇文章中，我们第一次将递归函数定义形式化。我们相信这种形式化有助于编程语言和作为计算理论发展的基础。接下来，我们将描述S-表达式和S-函数，给出一些例子，然后描述通用的S-函数`apply`，他在理论上作用于通用图灵机和实际作用在解释器。然后我们通过列表结构与Newell，Shaw，Simon`[2]`相似的方式描述S-表达式在IBM704中的内存使用的表述，然后通过程序来展示S-函数。之后我们会提及IBM 704 机器中LISP编程系统的主要功能，最终我们给出一个数据流表格的递归函数应用。
我们希望能够描述一些抽象计算因为LISP已经被用在其他论文中，而且能够在其他一些地方应用我们的形式化递归函数去描述数学逻辑和去解决机器理论证明。

# 2. 函数和函数的定义
通常我们考虑到函数时，我们应该需要大量的数学思想和符号。大多数思想是大家都知道的，但是符号表达式相信是是新事务。而且条件表达式的使用允许函数通过一种新的和可信的方式递归的定义。
a. **偏函数**  偏函数是被定义在它的部分域上的函数。当函数由算式定义时偏函数就非常必要，因为算式定义的一些参数的值可能没有终止。然而一些我们的基本函数应该被定义为偏函数。
b. **前置表达式和布尔函数** 一个前置表达式可能值为T（真）和F（假）.我们应该假定读者熟悉联结词 $\bigvee$(或) $\bigwedge$（与） $\lnot$ （非），典型的连接词是：
        
         x < y
         ( x < y ) ⋀（b==c）
         x is prime
布尔函数是真值包含T和F的函数
c. **条件表达式** 真值的依赖在数学中用断言的方式表述出来，||但是逻辑表达式的概念依赖于其他真值的数量是不充分的，所以英语单词和短语通常用来表达描述其他抽象依赖于文字。例如，函数$\lvert x \rvert$通常用单词来表述。条件表达式是用来表达前置表达式的数量和依赖的数量。一个条表达式有如下形式：

$(p_{1}\to e_{1},\cdots,p_{n}\to e_{n})$

$p$是前置表达式，$e$是任何形式的表达式。读作："如果$p_{1}$然后$e_{1}$否则如果$p_{2}$那么$e_{2}$,$\cdots$,否则如果$p_{n}$然后$e_{n}$"或者"$p_{1}$导出$e_{1}$,$\cdots$,$p_{n}$导出$e_{n}$"
    现在我们给定规则来确定$(p_{1}\to e_{1},\cdots,p_{n}\to e_{n})$的值是否已经被定义，和如果这样，它的值是什么。从左到右检查P的值，如果`p=T`而且这个P之前所有的P都没有定义过，然后这个条件表达式的值等于e（如果定义过）的值。如果任何没有定义的P没有遇到一个值为true的P或者所有的P都是FALSE，或者如果e等于第一个值为真的p是没有定义的，则条件表达式的值为没有定义，现在我们给出一些例子：
    【一些例子】
    条件表达式最简单的应用是有如下定义
    【一些定义】
    
d. **递归函数定义** 通过条件表达式我们能够不循环的通过公式来定义一些函数。例如，我们
【n的阶乘】
当我们使用公式来作用0!我们得到的结果为1；因为通过条件表达式的定义，无意义的表达式`0*(0-1)!`不会执行。通过此定义，计算2的阶乘的方法如下【2的阶乘】
这里我们给了两个其他的递归函数的定义。最通用的除法，`gcd(m,n)`根据欧几里得算法接受两个正整数m和n。这个算法通过如下递归函数来定义：
【gcd】
`rem(n,m)`返回n除以m的余数
牛顿迭代法得到a的近似平方根，开始于最初的近似值并且需要一个可以接受的近似值Y满足 |y^2 - a| < e ,可以写作`sqrt(a,x,e)`
=【】
几个函数同时进行的递归定义也是可能的，我们应该在需要的时候使用这些定义。
这里不保证递归定义的计算会永远的停止，比如，一个试图去计算n！的递归表达式，仅仅在n是非负整数的条件下成功。如果计算永远不终止，这个函数必须被认为在当前的参数下没有定义
前置连接词自身能够被条件表达式定义，例如：
【例子】
这里好像右手边的表达式有正确的真值表。如果我们考虑p或者q有可能undefined，V和到V将不再有联系。例如，如果p是假的q是undefined，我们可以根据之前的定义看到p到Vq是假的，但是q到Vp是undefined.因为我们的应用饥饿的。当p到Vq是由第一个计算过的p来计算的，而且如果p是假的q是不会计算的。我们应该使用后者来使用前缀表达式

e. 方程和形式。通常在数学，而不是数学逻辑中,没有正确使用“函数”并且将它表述到一些类似于“y^2+x”.因为我们应该在后面计算函数的表达式，我们需要函数和形式之间的一个界限和一个概念来表述这个区别。稍微跑题一些，我们使用Church`[3]`的做法来描述这个区别。
    让F是一个表达式，接受两个整数变量。`f(3,4)`是一个有意义的表达式。而且这个表达式的值是确定的。`y^2+x`这种表达式并不符合这个需求,`y^2+x(3,4)`不是一个传统的表达，如果我们企图去定义它，我们不会确定它会返回13或者19.Church称y^2+x为形式。一个形式能够转换成方程如果我们定义一个变量在形式中发生的方式，并且一个确定的参数列表。这个由church的lambda演算完成。
    如果e是一个形式，并且参数是x1，。。。，xn，然后r((x1,...,xn),e)会接收n个确定值的变量到函数中，然后重新排序后作用与e，并且计算出结果表达式，例如r((x,y),y^2+x)是一个两个参数变量的函数，r(x,y,y^2+x)(3,4) = 19
    于r-表达式中变量的列表是形式参数，`好像一个确定的整数中的变量`。所以，我们或许会改变函数表达式中绑定变量的名字在没有改变表达式值的情况下，提供我们能够在任何一个变量上做童颜的改变，而且不要让两个之前提供的变量相等。因此r(x,y,y^2+x),r(u,v,u^2+v),r(y,x,y^2+x)是同一个方程。
    我们应该经常使用一些变量绑定在R中的表达式。像这种表达式会被当做一个有参数的函数，没有绑定的变量被称做自由变量。
    一个适当的区分函数和形式的概念允许一个明确的`treatment`。这将会涉及到太多不相关的例子，但是我们应该在这篇paper中使用函数如同之后的文章中
    难度来自于结合r-表达式的描述或者牵扯到变量的其他定义。因为不同的绑定函数有可能表现出相同的符号。这叫做绑定变量的碰撞。这里有一个概念牵扯到被称作结合符的操作符，能够不使用变量结合函数。不幸的是，函数有趣的合并后的表达式表现的冗长和不可读。
    
f. **递归函数的表达式** 
R-表示法在表示命名函数递归是是不准确的。例如，使用r，我们能够转换定义：
    【sqrt】
但是右表达式不能被当做一个函数表达式来使用。因为在表达式中没有任何引用sqrt表示成一个完整的表达式
为了能够为递归函数写表达式。我们介绍另一个概念。label(a,e) 贡献e表达式。提供E中的a被看做是整个表达式，我们能够如此写：

将它当做sqrt的名字。
label(a,e)中的a也是绑定的，它可以在不改变表达式意思的情况下有条理的转换。但是，它和R中变量的绑定是不一样的。